# Introducing

### Computers in Society

Most people's ideas about computers come either from the movies (hackers) or from being made to use awful software in their own work, frequently badly designed software that makes them feel stupid for not knowing how to use it correctly.

Otherwise in popular culture and in the news, it's about building mobile apps or websites or where the latest security leak has happened. For me it's a hugely social and creative outlet and very much about self-expression.

One example of the extreme creative side of coding is Sam Aaron, inventor of sonic pi (later), who writes code in nightclubs all over the world. His code creates music which he performs live in front
club goers who usually can't tell it from a conventional dj.

Programming is a discovery process where we start off knowing nothing about how to approach a problem, and gradual uncover a solution as we work. It's easier than you think and it's also more fun than you think.




### Code, Code Everywhere

Software is now part of how the world works and
The more approachable we feel technology is, the more we play with it, take them apart, tinker with them, the better we a sense of what's possible we have.

Technology affects everything, AI in amazon recommendations, credit card fraud, making movies, medical research (data collection, analysis), medical devices (hearing aids), space exploration, home (Nest, Wifi, DVR), Cars (brakes, steering, engine control), iPods and mobiles

Post Routing, Netflix and Amazon recommendatjions, aeroplanes, cheque processing,financial transactions, cd-players, radio, GPS OS, TIVO, TV, iPod,

All general purpose computers but in special boxes with specific software that is not easy to change.
Often designed not to be changeable. X-Box is a standard windows pc but with good hard drive, good graphics card. fancy box.

Aeroplane is a set of networked computers in a really expensive fancy case.


## Inspiration

Space

Moon landing - guidance computer

Voyager computers

Mars rovers

Mars continuing mission




### Skills

Skills for thinking and communicating.
Social skills, like making a movie - lots of specialised skills coming together with a common objective and working together and communicating. Not about working in your bedroom any more (if it ever was).

Debugging good to confirm you version of reality. Often we think we have said one thing, the other person has understood something totally different

## History

30 minutes

Mozart the dead composer wrote his programs in standard music notation. Thats really what music is,
a written set of instructions for a human and a machine to carry out together. Human plays violin, piano etc. and even though Mozart is now dead, we can
still enjoy his music provided the musicians are able to carry out his instructions to the letter (with some interpretation). No one needs the ghost of the composer to be present to make sure that the "code"
runs.

The history of computers has been the history of humans telling machines what to do. In taking you through an extremely short history, I'd like to call out the contribution of women in this field because it isn't as well represented or understood as it should be.

### Witchcraft

Super-Computer inventor Danny Hillis described what computer programmers do as being akin to witchcraft. We carve special markings onto rocks (silicon chips), speak a special arcane language them (code) and they do what we tell them out in the world (programs). If that's not witchcraft, what is? To be a computer programmer in the 16th century would have seen you burnt at the stake.

### Looms

In the 1800s the Jacquard Loom was one of the first machines that didn't need a human operator, the pattern on the carpet or rug was defined, line by line by a series of cards with holds punched in them to indicate what the design should be. The machine started at the beginning of the stack and worked it's way through each one, line by line until it reached the end and the carpet was complete.

Before this time, machines were really meant as extensions of a person's capability and required their skill to use them. Lots of machines were made after the jacquard loom, still as single purpose devices but with some kind of configuration built into them. But you could not take a windmill and make it into a bakery.

### Babbage

In the 1830s, Charles Babbage had an idea for a more general purpose maths calculation machine. He got cash from parliament to build the machine (millions of pounds) but got bored with it half way through and started another project. It was never fully built and tested until fairly recently.

Despite not having a working machine, Ada Lovelace became the first programmer to write code for a "computer" in the 1840s and the machine didn't even exist!

### War

Lots of history goes by with machines becoming more complex and having more variability and control but they tended to stay in their little silos until WWII

WW II - As the Nazi's had come up with a fiendish plot to encrypt all their data, the good folk of Bletchley Park came together to try and solve the problem using Maths. Very interesting history and not revealed until the 1980s when it came into the daylight from the cover of the official secrets act.

### Turing's Universal Machine
Alan Turing had some thoughts about general purpose computing and posed the idea that you could build a machine that would know how to carry out a very small set of instructions but that the instructions would be structured in a way that they could be combined in lots of ways so that *any* problem could be solved by it if you could work out what the list of instructions should be. Like Babbage, Turing didn't build the computer, that was a team from the Post Office headed by an electrical engineer named Tommy Flowers. They built "Collosus" which was the first proper digital computer and helped with the war.

Lots of other efforts were going on in the US and around the world to solve the same problem so history can be quite hard fought for who has the honour of first "what".

Notable in these is Jean Bartik and the (all female) crew of the ENIAC which was a digital computer used to simulate bullet trajectories for wartime. Prior to this a computer was a person with a calculator using log table to work out trajectories in about a week. The ENIAC could do it before the shell landed.

### Bugs

Things that go wrong with code where we there is an outcome that we don't intend are called bugs. This comes from a time when computers were mostly electrical and electronics writ large, lots of wires,
switches, relays and valves. The first bug was literally an insect that got caught inside the workings
of an early machine and stopped it behaving as the programmers had intended. There is never any relation to rabbits.

### To the Moon and back

One part of JFK's mission to land a man on the moon that often isn't given enough credit is the guidance system that did all the calculations in real time to plot the path from the earth to the moon as both of them were speeding through space, turing around each other and around the sun. The computer that did that had less than 1 millionth the power of your mobile phone and nowhere near as much memory. The team lead on that project was a woman called Margaret Hamilton and the team had huge number of physical challenges that modern programmers just dont face today. One was the need to store the programs and data needed on the flight in memory. The only way to store that much memory at the time was in knitted memory, iron cores were magnetized and slotted into a woven matrix to create a binary image of the program.

### Modern Space !

Space exploration without humans and Mars in particular continues to be an area where software is crucial.  The Mars rover robots are all software controlled and mostly autonomous. Calculations of trajectories earth -> mars are all software (very complicated maths).

and another woman is notable for writing the parachute guidance systems in the recent mars mission where rovers were dropped from parachutes onto surface.

### Now

All this time, the processing of machines has got faster and faster as electronics have improved, got smaller, lighter, more reliable. We've gone from hard wired - physical wiring to switches, punched cards, paper tapes etc. so getting information into the machine and getting results back out has always been a challenge. Graphs drawn, lights, beeps and boops.

Often now the same computer in your DVR or x-box is the same as in your laptop but with different input controls and outputs and different software.

Errors

Also because of turings idea of the general purpose computer being able to work on any problem, there are usually many more ways to write a program. Some will run faster than others, some will use more resources and some bad ones will do both.

Programming languages are the struggle we humans have to tell computers how to work and still be able to reason about what we have written and allow others to understand what we have done and build upon it. Communication with other humans is at least as important.

Time Flies like an arrow
Fruit Flies like a banana

How do we interpret that?


Clear, careful thinking.

How do we represent data. What should the logic be. What should be the flow, what needs to happen first, what should come later?

### Babies

Computer programs when they work and you have all the kinks out of them, are a thing of wonder, sometimes can be beautiful. When they don't work, they are very like human babies. Crying to tell you something is wrong but not able to fully articulate what is wrong. Maybe they can point to the general area but it's often up to you as the adult human to find the problem and fix it.

### Nuance

Human Language, not just English, is too nuanced for computers to interpret correctly as a conversation between two intelligences.

Time Flies like an arrow

Fruit Flies like a banana

The constant struggle or balancing act is to make it easy for you to say waht you want bhile trying to be precise enought for a computer to follow and make sense of.

We will come back to this idea again and again.

### Part of the

## why

I believe everyone should learn something about how code works, like learning maths, not because you want everyone to be a mathematician, but because it's useful in any profession and the skills you learn are transferable to lots of other contexts.

### Errors

Part of the problem with being able to write a Turing complete language is that there is an infinite number of ways that you can put together those building blocks. Programs that interpret the languages - python - or that compile the language into something closer to the machine - compilers - have a difficult task in trying to make sense of literally anything that could be thrown at them. It also means that a tiny missed punctuation or spelling mistake can change a well ordered program into total nonsense to the computer. Sometimes you will see an error message (or many many error messages) that doesn't make any sense to you. With experience and some experimentation, you can learn what the baby means when it cries and how to go about fixing it.


## Mousse(e)

Menu

### languages

Low level languages:
Special small set of instructions that are designed to be easy and fast for a computer to process. Hard for humans to understand and reason about. Too much to keep in your head at one time. Limits the scale of how big an application you can write.

Languages have evolved - hard wiring and valves, physical connections, not easily changed, punched cards - configurable but things needed to be in the right place to work
Switches and Dials more configuration
Special Text - typed language but still columns, spacing etc is important. More configuration still and opportunity to make how you want it.
Free text - language interpreter does all the hard work of trying to understand what you type by how you assemble the list of building blocks.
Natural Language - Siri Cortana, artificial intelligence needs less formal grammar to be observed, can pick out words and decide on what it thinks you mean by context.

Sending command to siri is really running a program with different inputs. Show me a map of Newcastle city centre and show me a map of France are the same command (Show me a map), it's just the "Which Map" or which part of the map that changes.



### Voyager

Two of the oldest computers (and computer programs) still around are by now about 13 billion miles away at the very edge
of our solar system. They are the Voyager 1 and 2 spacecraft that were built in the 1970s and launched to tour the solar system. Each had a total amount of memory less than the picture you are looking at now (63 kilobytes) and were engineered to constantly overwrite data with new data once the old data was sent back to earth.




## Type of Programs

Batches - payroll, cheques, banks - overnight runs

Interactive - Windows, Mac OS, Mobile application

Procedural - Utility

Interpreted languages

Like python, scratch etc. Language is read and interpreted afresh each time the program runs. Gives quick turnaround for your changes. Not as performant, puts speed of development ahead of robustness and speed of execution.

Compiled programs

Microbit. Kind that run on the mars rover and need very precise control of parameters, built once and loaded onto the platform. Run quickly with minimum of overhead. Harder to write correctly but effort can be worth it.



http://eniacprogrammers.org/


## Notable people

A lot of the history of computers can seem like it's based around men and technology is only for young boys and men.  It's true that silicon valley and the tech industry does suffer from this kind of bias but historically that's not been true. As we go through I'd like to call out some of the areas tying into popular culture where women made notable contributions. This is not an exhaustive list but it's ammunition for arguments and resistance you might encounter for "it's just not for me".

### Grace Hopper

Wife and Mother, Admiral in the US Navy. Invented the first compiler. Helped to invent the first "high level" language - Cobol.

"Nobody believed it. I had a running compiler and nobody would touch it. They carefully told me, computers only do arithmetic; they could not do programs."


Was at Harvard when the first bug was documented and popularised the term in relation to computing.

"The most important thing I’ve accomplished, other than building the compiler, is training young people. They come to me, you know, and say, ‘Do you think we can do this?’ I say, “Try it.” And I back ’em up. They need that. I keep track of them as they get older and I stir ’em up at intervals so they don’t forget to take chances"

Retired from the Navy at 80 as an admiral.


## Margaret Hamilton

Managed project to calculate moon landing, running a progam on a computer 1 million times less powerful than the mobile phone you have in your pocket.

Nearly didn't land on the moon. Aldrin found switch had been misplaced and meant program was getting too much information than it should have been getting. Margaret's program recognized the problem, shut down the misbehaving parts and continued with the most important tasks - calculating the landing.



## Katherine Johnson

Unsung maths hero and programmer, calculations of trajectories used throughout the space program. Mercury 1950-60s, Apollo in the 60-70s up to space shuttle missions in the 80s. First human in space, first human in space, first humans on the moon. Calculated trajectories to go earth to moon and back again. Difficult to do since, earth, moon, sun are all moving in space, plus rocket is moving too.

“I felt most proud of the success of the Apollo mission. They were going to the moon and I computed the path to get there.”


### Jean Bartik

“I was told I’d never make VP rank because I was too outspoken. Maybe so, but I think men will always find an excuse for keeping women in their ‘place’. So, let’s make that place the executive suite and start more of our own companies.” – Jean Bartik





Teaching computational thinking:

Not simply teaching how programming works, we need to ensure that young people can understand the way that human concerns are translated into problems that computers can help solve. Like media literacy or general critical thinking skills, we should provide this information as a necessary part of teaching students to understand the systems that run the world around them. It’s essential that concerns like ethics and systemic biases be incorporated into any education about technology systems.
Applied CS over theory: A lot of yesterday’s computer science programs emphasized abstract concepts that could often be hard to translate into practical impact. Given that more students have access to technology in their everyday lives than ever before, recontextualizing CS education to connect directly to the tools and devices they already use can ensure that what we’re teaching is relevant. By analogy, we’re going to need a lot more electricians than electrical engineers, even if we know that the two related disciplines are both important and valuable.
Jobs in every industry, not tech startups: While we shouldn’t add to curriculum simply to satisfy the demands of industry, it’s reasonable to want to make sure education can translate into real-world jobs. The vast majority of technology jobs, both today and in the future, are outside of the signature startups and tech titans of Silicon Valley, in technical roles in companies that are otherwise not seen as being primarily in “tech”. These jobs may not have the high profile of Google or Facebook, but companies with a longer track record are likely to be stable, more geographically distributed, and aligned with the career and life goals of a broader swath of the population. We can de-emphasize the high-risk startup style of tech employment in favor of a much more accommodating style that could be described as blue-collar coding.
It’s not about making more programmers: While a lot of young people who learn about computer science may choose to go into programming or engineering or related disciplines, we should not design curricula with the goal of turning everyone into a coder. Every industry, every creative discipline, every line of work from farming to fashion, engineering to english, management to marketing, can be improved by including insights provided by being deeply technologically literate. It’s possible to teach computer science in a way where it amplifies the interests and ambitions that young people have in any discipline, and unlocks their full potential in whatever field they find meaningful.


### models

We build models of the world inside our code to solve the problem at hand. We simplify, ignore inconvenient pieces and structure our models to reflect the part of the world that we are concerned with addressing. We don't try to model the world in exact detail. For example, if we are modelling a car rental business, we might care about renters, their credit cards, the vehicles identification, dates and locations. We probably don't care about any of the books the renters bought recently, any of the films they watched, what design awards each car has won etc.

Models need to be good enough for our purpose and no better - that just wastes time and makes things more complicated than they need to be.

Don't be fooled into thinking the model has to represent reality fully.

Metro map - not actual scale but gives you a good idea if you are one place, how many stations, roughly how far it is, do you need to change train. If there's a problem, could you get there some other way?

Ceci nest pas un participate
