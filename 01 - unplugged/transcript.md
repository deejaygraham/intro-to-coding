# Coding Unplugged


## Unplugged

1 hour

(Mr Robot)

We don't need a computer or any electronics to have a wonderful time doing programming. The computer is good a repeating instructions very, very quickly and is best thought of as a tool that extends what you personally are capable of.

Beginning coders need to experience a wide range of problems and to experiment in solving them using different strategies. The process is something like planning a strategy, designing a solution, writing the solution. Running the solution then reflecting on their solution and comparing their results with others. As with most other subjects, the process by which you arrive at a solution is more important than finding the right answer.

The most important skills for programming are clear, critical thinking, logic, visualization and imagination. Because of that we can do a lot of programming using pencil and paper or
human machines. We start off with a problem and we have to try to understand that problem, it's usually too big to solve all in one go, and be able to break it up into smaller pieces, smaller problems that we can decide if they are the right size or do they have other, smaller problems hidden inside them?
We use metaphors to describe how our program is like the world and how the parts of our program fit together like the parts in the real world.
We also try to create a model of the world that helps to solve the problem in a way that we can represent easily inside our heads and inside the computer. That model only needs to be as good as it needs to be to deal with the problem, it should not model the entire universe in full detail (we will come back to this).

In explaining what we want to do, we often (like english and poetry) can take a long time finding the exact right word and often when we pick the wrong word, others (or computers) can be confused and do the wrong thing or we can ask for the thing we want in the wrong way.

Can you pass me the thing - is it a pencil, pen, table, ?

Often the challenge of programming is saying what you mean in as concise a way as possible. Your programs need to communicate with two different parties - other humans who may reuse and build on your work, and the computer who has to do what you tell it. In this instance, the person acting out the instructions needs to understand what you want them to do.

Link to robot instructions.

Exercises like this are really what you are doing when you are programming "for real" using a computer,
most of the activity is going on in your head. The program comes as a result of your thinking, not something inherent in the machine itself.

Later on when you are writing a program, it can be helpful to adopt these strategies to debug a program that doesn't do what you want. Or mostly does what you want but sometimes goes wrong.

Pencil and paper debugging

Rubber Ducking - explaining the problem and what might be the cause of it.

Using the scientific method

Hypothesis. If that'strue what would we expect - look for ways your theory confirms what you see. Look for ways it contradicts what you see.


Computers are used to working with very exacting language (the kind of rigour you only find in philosophy and mathematics or physics).
Algorithms



### Put things in the right  order

Have a bath
Bathing
Turn bath water on
Get into Bath
Wash
Get out of the Bath

Change the tyre on a car

Have a birthday party
Set plates
Set knives and forks
bring out the food
spread the table cloth

Eat at restaurant

Eat food
Full?
No
Yes
Pay bill
Leave

Make a sandwich



Role play



Different robots understand different instructions. Some are mathematical, some are more general,
some know about tea and milk, others can do the same job but need to be told exactly wehre to go
exact positions, exact commands. High level vs low level languages.

Can we divide a chocolate bar into 12 equal pieces. How do we do that? What would be the process for doing it. Can the students write down a process to do it. Can it be generalised to work with any size of bar and any number of pieces? What are the limits? Odd even numbers? Physical size?


We've been talking about algorithms.

What makes a good algorithm. If you are making lunch for yourself, how long it takes could be your only requirement. You might be hungry. If you are a chef trying to feed 1000 people at a banquet and have to coordinate 100 kitchen staff, efficiency and speed might not be the consideration you choose. What if
everyone is wanting the butter or a knife at the same time? Does everyone need their own fridge.

Depending on what you want to achieve, your algorithm might work but take a lot longer or it might not work at all.

Does you algorithm have to change when faced by with the real world. How does it match up. Are there big changes or small changes.


Now we've got some mad programming skillz, lets move on to using a programming language on some actual computers.
